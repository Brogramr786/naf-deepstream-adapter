{"version":3,"sources":["webpack:///webpack/bootstrap fd014b6c3e937fcf2da0","webpack:///./src/index.js","webpack:///./src/WebRtcPeer.js"],"names":[],"mappings":"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","file":"naf-deepstream-adapter.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fd014b6c3e937fcf2da0","var WebRtcPeer = require(\"./WebRtcPeer\");\r\n\r\nclass DeepstreamWebRtcAdapter {\r\n  /**\r\n      Config structure:\r\n      config.url: 'YOUR_URL_HERE'\r\n    */\r\n  constructor(ds, config) {\r\n    this.rootPath = \"networked-aframe\";\r\n\r\n    this.localId = null;\r\n    this.appId = null;\r\n    this.roomId = null;\r\n\r\n    this.peers = {}; // id -> WebRtcPeer\r\n    this.occupants = {}; // id -> joinTimestamp\r\n\r\n    config = config || window.deepstreamConfig;\r\n    this.ds = ds || window.deepstream;\r\n\r\n    if (this.ds === undefined) {\r\n      throw new Error(\r\n        \"Import https://cdnjs.cloudflare.com/ajax/libs/deepstream.io-client-js/x.x.x/deepstream.js\"\r\n      );\r\n    }\r\n\r\n    this.dsUrl = config.url;\r\n  }\r\n\r\n  /*\r\n   * Call before `connect`\r\n   */\r\n\r\n  setServerUrl(url) {\r\n    // handled in config\r\n  }\r\n\r\n  setApp(appId) {\r\n    this.appId = appId;\r\n  }\r\n\r\n  setRoom(roomId) {\r\n    this.roomId = roomId;\r\n  }\r\n\r\n  // options: { datachannel: bool, audio: bool }\r\n  setWebRtcOptions(options) {\r\n    // TODO: support audio and video\r\n    if (options.datachannel === false)\r\n      console.warn(\r\n        \"DeepstreamWebRtcAdapter.setWebRtcOptions: datachannel must be true.\"\r\n      );\r\n    if (options.audio === true)\r\n      console.warn(\"DeepstreamWebRtcAdapter does not support audio yet.\");\r\n    if (options.video === true)\r\n      console.warn(\"DeepstreamWebRtcAdapter does not support video yet.\");\r\n  }\r\n\r\n  setServerConnectListeners(successListener, failureListener) {\r\n    this.connectSuccess = successListener;\r\n    this.connectFailure = failureListener;\r\n  }\r\n\r\n  setRoomOccupantListener(occupantListener) {\r\n    this.occupantListener = occupantListener;\r\n  }\r\n\r\n  setDataChannelListeners(openListener, closedListener, messageListener) {\r\n    this.openListener = openListener;\r\n    this.closedListener = closedListener;\r\n    this.messageListener = messageListener;\r\n  }\r\n\r\n  connect() {\r\n    var self = this;\r\n    var ds = this.ds;\r\n\r\n    var dsClient = this.ds(this.dsUrl);\r\n    this.dsClient = dsClient;\r\n\r\n    dsClient.login({}, function(success, data) {\r\n      if (success) {\r\n        self.startApp(data.id);\r\n      } else {\r\n        // TODO failure messages\r\n        self.connectFailure();\r\n      }\r\n    });\r\n\r\n    dsClient.presence.getAll(function(ids) {\r\n      // ids.forEach(subscribeToAvatarChanges)\r\n      console.log(\"existing clients\", ids);\r\n      for (var i = 0; i < ids.length; i++) {\r\n        self.clientConnected(ids[i]);\r\n      }\r\n    });\r\n\r\n    dsClient.presence.subscribe((clientId, isOnline) => {\r\n      console.log(\"client presence id\", clientId, \"online?\", isOnline);\r\n      if (isOnline) {\r\n        self.clientConnected(clientId);\r\n      } else {\r\n        self.clientDisconnected(clientId);\r\n      }\r\n    });\r\n  }\r\n\r\n  shouldStartConnectionTo(client) {\r\n    return (this.myRoomJoinTime || 0) <= (client ? client.roomJoinTime : 0);\r\n  }\r\n\r\n  startStreamConnection(clientId) {\r\n    // Handled by WebRtcPeer\r\n  }\r\n\r\n  closeStreamConnection(clientId) {\r\n    // Handled by WebRtcPeer\r\n  }\r\n\r\n  sendData(clientId, dataType, data) {\r\n    this.peers[clientId].send(dataType, data);\r\n  }\r\n\r\n  sendDataGuaranteed(clientId, dataType, data) {\r\n    var clonedData = JSON.parse(JSON.stringify(data));\r\n    this.dsClient.record.getRecord(this.getUserPath(this.localId)).set(\"data\", {\r\n      to: clientId,\r\n      type: dataType,\r\n      data: clonedData\r\n    });\r\n  }\r\n\r\n  broadcastData(dataType, data) {\r\n    for (var clientId in this.peers) {\r\n      if (this.peers.hasOwnProperty(clientId)) {\r\n        this.sendData(clientId, dataType, data);\r\n      }\r\n    }\r\n  }\r\n\r\n  broadcastDataGuaranteed(dataType, data) {\r\n    for (var clientId in this.peers) {\r\n      if (this.peers.hasOwnProperty(clientId)) {\r\n        this.sendDataGuaranteed(clientId, dataType, data);\r\n      }\r\n    }\r\n  }\r\n\r\n  getConnectStatus(clientId) {\r\n    var peer = this.peers[clientId];\r\n\r\n    if (peer === undefined) return NAF.adapters.NOT_CONNECTED;\r\n\r\n    switch (peer.getStatus()) {\r\n      case WebRtcPeer.IS_CONNECTED:\r\n        return NAF.adapters.IS_CONNECTED;\r\n\r\n      case WebRtcPeer.CONNECTING:\r\n        return NAF.adapters.CONNECTING;\r\n\r\n      case WebRtcPeer.NOT_CONNECTED:\r\n      default:\r\n        return NAF.adapters.NOT_CONNECTED;\r\n    }\r\n  }\r\n\r\n  /*\r\n   * Privates\r\n   */\r\n\r\n  startApp(clientId) {\r\n    var self = this;\r\n    var dsClient = this.dsClient;\r\n    this.localId = clientId;\r\n    this.localTimestamp = NAF.utils.now();\r\n\r\n    dsClient.record.getRecord(this.getUserPath(clientId)).set({\r\n      timestamp: this.localTimestamp, // TODO get this from server\r\n      signal: \"\",\r\n      data: \"\"\r\n    });\r\n    self.connectSuccess(clientId);\r\n  }\r\n\r\n  clientConnected(clientId) {\r\n    console.log(\"new client\", clientId);\r\n    var self = this;\r\n    var dsClient = this.dsClient;\r\n\r\n    if (!NAF.connection.isConnected()) {\r\n      console.warn(\r\n        \"Trying to make a connection to another client before my client has connected\"\r\n      );\r\n    }\r\n\r\n    dsClient.record\r\n      .getRecord(this.getUserPath(clientId))\r\n      .whenReady(function(clientRecord) {\r\n        var onClientSetup = function(timestamp) {\r\n          // if (remoteId === self.localId || remoteId === 'timestamp' || self.peers[remoteId] !== undefined) return;\r\n\r\n          var remoteTimestamp = clientRecord.get(\"timestamp\");\r\n          console.log(\"remote timestamp\", remoteTimestamp);\r\n\r\n          var peer = new WebRtcPeer(\r\n            self.localId,\r\n            clientId,\r\n            // send signal function\r\n            function(data) {\r\n              console.log(\"setting signal\", data);\r\n              dsClient.record\r\n                .getRecord(self.getUserPath(self.localId))\r\n                .set(\"signal\", data);\r\n            }\r\n          );\r\n          peer.setDatachannelListeners(\r\n            self.openListener,\r\n            self.closedListener,\r\n            self.messageListener\r\n          );\r\n\r\n          self.peers[clientId] = peer;\r\n          self.occupants[clientId] = remoteTimestamp;\r\n\r\n          // received signal\r\n          clientRecord.subscribe(\"signal\", function(data) {\r\n            console.log(\"received signal\", data);\r\n            var value = data;\r\n            if (value === null || value === \"\") return;\r\n            peer.handleSignal(value);\r\n          });\r\n\r\n          // received data\r\n          clientRecord.subscribe(\"data\", function(data) {\r\n            console.log(\"received data\", data);\r\n            var value = data;\r\n            if (value === null || value === \"\" || value.to !== self.localId)\r\n              return;\r\n            self.messageListener(clientId, value.type, value.data);\r\n          });\r\n\r\n          // send offer from a peer who\r\n          //   - later joined the room, or\r\n          //   - has larger id if two peers joined the room at same time\r\n          console.log(\r\n            \"checking to see who should send offer\",\r\n            self.localTimestamp > remoteTimestamp,\r\n            self.localTimestamp === remoteTimestamp && self.localId > clientId\r\n          );\r\n          if (\r\n            self.localTimestamp > remoteTimestamp ||\r\n            (self.localTimestamp === remoteTimestamp && self.localId > clientId)\r\n          ) {\r\n            console.log(\"this client is sending offer\");\r\n            peer.offer();\r\n          }\r\n\r\n          self.occupantListener(self.occupants);\r\n        };\r\n\r\n        if (clientRecord.get(\"timestamp\") === undefined) {\r\n          clientRecord.subscribe(\"timestamp\", onClientSetup);\r\n        } else {\r\n          onClientSetup(clientRecord.get(\"timestamp\"));\r\n        }\r\n      });\r\n  }\r\n\r\n  clientDisconnected() {\r\n    // TODO\r\n  }\r\n\r\n  /*\r\n   * realtime database layout\r\n   *\r\n   * /rootPath/appId/roomId/\r\n   *   - /userId/\r\n   *     - timestamp: joining the room timestamp\r\n   *     - signal: used to send signal\r\n   *     - data: used to send guaranteed data\r\n   *   - /timestamp/: working path to get timestamp\r\n   *     - userId:\r\n   */\r\n\r\n  getRootPath() {\r\n    return this.rootPath;\r\n  }\r\n\r\n  getAppPath() {\r\n    return this.getRootPath() + \"/\" + this.appId;\r\n  }\r\n\r\n  getRoomPath() {\r\n    return this.getAppPath() + \"/\" + this.roomId;\r\n  }\r\n\r\n  getUserPath(id) {\r\n    return this.getRoomPath() + \"/\" + id;\r\n  }\r\n\r\n  getSignalPath(id) {\r\n    return this.getUserPath(id) + \"/signal\";\r\n  }\r\n\r\n  getDataPath(id) {\r\n    return this.getUserPath(id) + \"/data\";\r\n  }\r\n\r\n  getTimestampGenerationPath(id) {\r\n    return this.getRoomPath() + \"/timestamp/\" + id;\r\n  }\r\n}\r\n\r\nNAF.adapters.register(\"deepstream\", DeepstreamWebRtcAdapter);\r\n\r\nmodule.exports = DeepstreamWebRtcAdapter;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","class WebRtcPeer {\r\n  constructor(localId, remoteId, sendSignalFunc) {\r\n    this.localId = localId;\r\n    this.remoteId = remoteId;\r\n    this.sendSignalFunc = sendSignalFunc;\r\n    this.open = false;\r\n    this.channelLabel = \"networked-aframe-channel\";\r\n\r\n    this.pc = this.createPeerConnection();\r\n    this.channel = null;\r\n  }\r\n\r\n  setDatachannelListeners(openListener, closedListener, messageListener) {\r\n    this.openListener = openListener;\r\n    this.closedListener = closedListener;\r\n    this.messageListener = messageListener;\r\n  }\r\n\r\n  offer() {\r\n    var self = this;\r\n    // reliable: false - UDP\r\n    this.setupChannel(\r\n      this.pc.createDataChannel(this.channelLabel, { reliable: false })\r\n    );\r\n    console.log(\"creating offer\");\r\n    this.pc.createOffer(\r\n      function(sdp) {\r\n        console.log(\"created offer\");\r\n        self.handleSessionDescription(sdp);\r\n      },\r\n      function(error) {\r\n        console.error(\"WebRtcPeer.offer: \" + error);\r\n      }\r\n    );\r\n  }\r\n\r\n  handleSignal(signal) {\r\n    console.log(\"handleSignal\", signal);\r\n    // ignores signal if it isn't for me\r\n    if (this.localId !== signal.to || this.remoteId !== signal.from) return;\r\n\r\n    switch (signal.type) {\r\n      case \"offer\":\r\n        this.handleOffer(signal);\r\n        break;\r\n\r\n      case \"answer\":\r\n        this.handleAnswer(signal);\r\n        break;\r\n\r\n      case \"candidate\":\r\n        this.handleCandidate(signal);\r\n        break;\r\n\r\n      default:\r\n        console.error(\r\n          \"WebRtcPeer.handleSignal: Unknown signal type \" + signal.type\r\n        );\r\n        break;\r\n    }\r\n  }\r\n\r\n  send(type, data) {\r\n    // TODO: throw error?\r\n    if (this.channel === null || this.channel.readyState !== \"open\") return;\r\n\r\n    this.channel.send(JSON.stringify({ type: type, data: data }));\r\n  }\r\n\r\n  getStatus() {\r\n    if (this.channel === null) return WebRtcPeer.NOT_CONNECTED;\r\n\r\n    switch (this.channel.readyState) {\r\n      case \"open\":\r\n        return WebRtcPeer.IS_CONNECTED;\r\n\r\n      case \"connecting\":\r\n        return WebRtcPeer.CONNECTING;\r\n\r\n      case \"closing\":\r\n      case \"closed\":\r\n      default:\r\n        return WebRtcPeer.NOT_CONNECTED;\r\n    }\r\n  }\r\n\r\n  /*\r\n     * Privates\r\n     */\r\n\r\n  createPeerConnection() {\r\n    var self = this;\r\n    var RTCPeerConnection =\r\n      window.RTCPeerConnection ||\r\n      window.webkitRTCPeerConnection ||\r\n      window.mozRTCPeerConnection ||\r\n      window.msRTCPeerConnection;\r\n\r\n    if (RTCPeerConnection === undefined) {\r\n      throw new Error(\r\n        \"WebRtcPeer.createPeerConnection: This browser does not seem to support WebRTC.\"\r\n      );\r\n    }\r\n\r\n    var pc = new RTCPeerConnection({ iceServers: WebRtcPeer.ICE_SERVERS });\r\n\r\n    pc.onicecandidate = function(event) {\r\n      console.log(\"onicecandidate\");\r\n      if (event.candidate) {\r\n        self.sendSignalFunc({\r\n          from: self.localId,\r\n          to: self.remoteId,\r\n          type: \"candidate\",\r\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\r\n          candidate: event.candidate.candidate\r\n        });\r\n      }\r\n    };\r\n\r\n    // Note: seems like channel.onclose hander is unreliable on some platforms,\r\n    //       so also tries to detect disconnection here.\r\n    pc.oniceconnectionstatechange = function() {\r\n      console.log(\"oniceconnectionstatechange\");\r\n      if (self.open && pc.iceConnectionState === \"disconnected\") {\r\n        self.open = false;\r\n        self.closedListener(self.remoteId);\r\n      }\r\n    };\r\n\r\n    return pc;\r\n  }\r\n\r\n  setupChannel(channel) {\r\n    var self = this;\r\n\r\n    this.channel = channel;\r\n\r\n    // received data from a remote peer\r\n    this.channel.onmessage = function(event) {\r\n      console.log(\"received data from remote peer\");\r\n      var data = JSON.parse(event.data);\r\n      self.messageListener(self.remoteId, data.type, data.data);\r\n    };\r\n\r\n    // connected with a remote peer\r\n    this.channel.onopen = function(event) {\r\n      console.log(\"connected to a remote peer\");\r\n      self.open = true;\r\n      self.openListener(self.remoteId);\r\n    };\r\n\r\n    // disconnected with a remote peer\r\n    this.channel.onclose = function(event) {\r\n      console.log(\"discnnected to a remote peer\");\r\n      if (!self.open) return;\r\n      self.open = false;\r\n      self.closedListener(self.remoteId);\r\n    };\r\n\r\n    // error occurred with a remote peer\r\n    this.channel.onerror = function(error) {\r\n      console.error(\"WebRtcPeer.channel.onerror: \" + error);\r\n    };\r\n  }\r\n\r\n  handleOffer(message) {\r\n    console.log(\"handleOffer\");\r\n    var self = this;\r\n\r\n    this.pc.ondatachannel = function(event) {\r\n      self.setupChannel(event.channel);\r\n    };\r\n\r\n    this.setRemoteDescription(message);\r\n\r\n    this.pc.createAnswer(\r\n      function(sdp) {\r\n        self.handleSessionDescription(sdp);\r\n      },\r\n      function(error) {\r\n        console.error(\"WebRtcPeer.handleOffer: \" + error);\r\n      }\r\n    );\r\n  }\r\n\r\n  handleAnswer(message) {\r\n    this.setRemoteDescription(message);\r\n  }\r\n\r\n  handleCandidate(message) {\r\n    var self = this;\r\n    var RTCIceCandidate =\r\n      window.RTCIceCandidate ||\r\n      window.webkitRTCIceCandidate ||\r\n      window.mozRTCIceCandidate;\r\n\r\n    this.pc.addIceCandidate(\r\n      new RTCIceCandidate(message),\r\n      function() {},\r\n      function(error) {\r\n        console.error(\"WebRtcPeer.handleCandidate: \" + error);\r\n      }\r\n    );\r\n  }\r\n\r\n  handleSessionDescription(sdp) {\r\n    console.log(\"handleSessionDescription\", sdp);\r\n    var self = this;\r\n\r\n    this.pc.setLocalDescription(\r\n      sdp,\r\n      function() {},\r\n      function(error) {\r\n        console.error(\"WebRtcPeer.handleSessionDescription: \" + error);\r\n      }\r\n    );\r\n\r\n    this.sendSignalFunc({\r\n      from: this.localId,\r\n      to: this.remoteId,\r\n      type: sdp.type,\r\n      sdp: sdp.sdp\r\n    });\r\n  }\r\n\r\n  setRemoteDescription(message) {\r\n    var self = this;\r\n    var RTCSessionDescription =\r\n      window.RTCSessionDescription ||\r\n      window.webkitRTCSessionDescription ||\r\n      window.mozRTCSessionDescription ||\r\n      window.msRTCSessionDescription;\r\n\r\n    this.pc.setRemoteDescription(\r\n      new RTCSessionDescription(message),\r\n      function() {},\r\n      function(error) {\r\n        console.error(\"WebRtcPeer.setRemoteDescription: \" + error);\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\nWebRtcPeer.IS_CONNECTED = \"IS_CONNECTED\";\r\nWebRtcPeer.CONNECTING = \"CONNECTING\";\r\nWebRtcPeer.NOT_CONNECTED = \"NOT_CONNECTED\";\r\n\r\nWebRtcPeer.ICE_SERVERS = [\r\n  { urls: \"stun:stun.l.google.com:19302\" },\r\n  { urls: \"stun:stun1.l.google.com:19302\" },\r\n  { urls: \"stun:stun2.l.google.com:19302\" },\r\n  { urls: \"stun:stun3.l.google.com:19302\" },\r\n  { urls: \"stun:stun4.l.google.com:19302\" }\r\n];\r\n\r\nmodule.exports = WebRtcPeer;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/WebRtcPeer.js"],"sourceRoot":""}